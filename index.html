<!DOCTYPE html>
<html>
<head>
    <style>
        .maze-field {
            width: 300px;
            height: 300px;
            margin: 50px auto;
            background-color: #666;
            position: relative;
        }
        .cell {
            position: absolute;
            background-color: darkgray;
            box-sizing: border-box;
            border: 1px solid #000;
        }
    </style>
    <title>Document</title>
</head>
<body>
    <div class="maze-field">
    </div>
    
    <script>
        function Maze() {
            this.width = 300;
            this.height = 300;
            this.mazeField = [];
            this.historyCellVisited = [];
            this.tagElem = document.querySelector(".maze-field");
        }
        
        Maze.prototype.createMaze = function(cellSize) {
            for(let i = 0; i < this.height; i += cellSize.height) {
                let mazeFieldSubArray = [];
                for(let j = 0; j < this.width; j += cellSize.width) {
                    let cell = new Cell(cellSize.width, cellSize.height, j, i);
                    cell.createCellInsideMaze(this.tagElem);
                    mazeFieldSubArray.push(cell);
                }
                this.mazeField.push(mazeFieldSubArray);
            }
        }

        Maze.prototype.getCellRandomly = function() {
            let yCoor = Math.floor(Math.random() * this.mazeField.length);
            let xCoor = Math.floor(Math.random() * this.mazeField.length);
            return this.mazeField[yCoor][xCoor];
        }

        Maze.prototype.getAdjacentCell = function(cell) {
            let randAdjacentSelected;
            let adjacentCellsDirection = [];

            if(cell.y / 20 - 1 >= 0) {
                
                let cellAdjacentTop = this.mazeField[cell.y / 20 - 1][cell.x / 20];
                if(cellAdjacentTop.visited === false) {
                    cellAdjacentTop.direction = "top";
                    adjacentCellsDirection.push(cellAdjacentTop);
                }
                    
            }
            
            if(cell.y / 20 + 1 <= 14) {
                
                let cellAdjacentBottom = this.mazeField[cell.y / 20 + 1][cell.x / 20];
                if(cellAdjacentBottom.visited === false) {
                    cellAdjacentBottom.direction = "bottom";
                    adjacentCellsDirection.push(cellAdjacentBottom);
                }
                    
            }
            
            if(cell.x / 20 + 1 <= 14) {
                
                let cellAdjacentRight = this.mazeField[cell.y / 20][cell.x / 20 + 1];
                if(cellAdjacentRight.visited === false) {
                    cellAdjacentRight.direction = "right";
                    adjacentCellsDirection.push(cellAdjacentRight);    
                }
            }

            if(cell.x / 20 - 1 >= 0) {
               
                let cellAdjacentLeft = this.mazeField[cell.y / 20][cell.x / 20 - 1];
                if(cellAdjacentLeft.visited === false) {
                    cellAdjacentLeft.direction = "left";
                    adjacentCellsDirection.push(cellAdjacentLeft);
                }
            }

            if(adjacentCellsDirection.length > 0) {
                this.historyCellVisited.push(cell);
                let randIndex = Math.floor(Math.random() * adjacentCellsDirection.length);
                randAdjacentSelected = adjacentCellsDirection[randIndex];
                return randAdjacentSelected;
            }
            return this.historyCellVisited.pop();
        }

        function Cell(width, height, x, y) {
            this.width = width;
            this.height = height;
            this.x = x;
            this.y = y;
            this.visited = false;
        }

        Cell.prototype.createCellInsideMaze = function(mazeTagElem) {
            let cell = document.createElement("div");
            mazeTagElem.appendChild(cell);
            cell.classList.add("cell");
            
            cell.style.width = `${this.width}px`;
            cell.style.height = `${this.height}px`;
            cell.style.top = `${this.y}px`;
            cell.style.left = `${this.x}px`;
            
            cell.setAttribute("id", `cell_${this.x}_${this.y}`);
            this.cellTagElem = document.getElementById(`cell_${this.x}_${this.y}`);

        }

        Cell.prototype.removeBackground = function() {
            this.cellTagElem.style.backgroundColor = "#666";
        }

        Cell.prototype.removeBorderOfAdjacentCell = function() {
            switch(this.direction) {
                case "top":
                    this.cellTagElem.style.borderBottom = "none";        
                    break;
                case "bottom":
                    this.cellTagElem.style.borderTop = "none";
                    break;
                case "right":
                    this.cellTagElem.style.borderLeft = "none";        
                    break;
                case "left":
                    this.cellTagElem.style.borderRight = "none";        
                    break;
            }
        }

        Cell.prototype.removeBorderCurrentCell = function(adjacentCell) {
            /**
             * Every cell border visualization is made by two borders
             * example: cell1.right + cell2.left or cell20.bottom + cell30.top
             * At the moment that the currentcell is going back to cells that has
             * been visited it returns because otherwise it will remove one 
             * of the borders that has visited previously 
             */ 
            if(adjacentCell.visited)
                return;
            
            switch(adjacentCell.direction) {
                case "top":
                    this.cellTagElem.style.borderTop = "none";
                    break;
                case "bottom":
                    this.cellTagElem.style.borderBottom = "none";
                    break;
                case "right":
                    this.cellTagElem.style.borderRight = "none";
                    break;
                case "left":
                    this.cellTagElem.style.borderLeft = "none";
                    break;
            }
        }

        Cell.prototype.makeCellWhite = function() {
            this.cellTagElem.style.backgroundColor = "#fff";
        }

        let maze = new Maze();
        let cellSize = {
            width: 20,
            height: 20,
        };
        maze.createMaze(cellSize);
        let currentCell = maze.getCellRandomly();
        currentCell.makeCellWhite();
        currentCell.visited = true;
        
        setInterval(function() {
            let adjacentCell = maze.getAdjacentCell(currentCell);
            currentCell.removeBackground(); 
            currentCell.removeBorderCurrentCell(adjacentCell);

            adjacentCell.makeCellWhite();
            adjacentCell.removeBorderOfAdjacentCell();
            adjacentCell.visited = true;
            currentCell = adjacentCell;
        },100);
        
    </script>
</body>
</html>